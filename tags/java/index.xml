<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 无糖拿铁，谢谢</title><link>/tags/java/</link><description>Recent content in Java on 无糖拿铁，谢谢</description><generator>Hugo -- gohugo.io</generator><copyright>CC BY-NC 4.0 CN</copyright><lastBuildDate>Mon, 24 Feb 2020 21:09:31 +0000</lastBuildDate><atom:link href="/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Gradle 的 Java 插件构建 Java 项目</title><link>/posts/use-gradle-to-build-java-project/</link><pubDate>Mon, 24 Feb 2020 21:09:31 +0000</pubDate><guid>/posts/use-gradle-to-build-java-project/</guid><description>在上一篇文章中，我们在没有使用任何插件的情况下，练习了使用 Gradle 构建 Java 项目，最后得到一个脆弱的构建脚本和不符合约定的目录结构。 对此，Gradle</description></item><item><title>使用 Gradle 但不使用 Java 插件构建 Java 项目</title><link>/posts/use-gradle-to-build-java-project-without-plugin/</link><pubDate>Sat, 22 Feb 2020 23:42:35 +0000</pubDate><guid>/posts/use-gradle-to-build-java-project-without-plugin/</guid><description>本文目标是探索在没有使用任何额外插件的情况下，如何使用 Gradle 构建一个 Java 项目，以此对比使用 Java 插件时得到的好处。 初始化项目 使用 Gradle Init 插件提供的 init task 来创</description></item><item><title>Java内存回收算法介绍</title><link>/posts/java-memory-collection-algorithms/</link><pubDate>Sun, 10 Feb 2019 22:18:24 +0000</pubDate><guid>/posts/java-memory-collection-algorithms/</guid><description>JVM 提供了自动化的内存管理，使得开发者不需要编写内存回收的代码。但是，JVM 是如何工作的呢？是如何知道哪些内存应该被清理呢？又如何减小垃圾回收</description></item><item><title>「Java 8 函数式编程」读书笔记——数据并行化</title><link>/posts/java_8_lambdas_functional_programming_note_parallel/</link><pubDate>Mon, 20 Feb 2017 00:00:00 +0000</pubDate><guid>/posts/java_8_lambdas_functional_programming_note_parallel/</guid><description>本书第六章的读书笔记，也是我这个系列的最后一篇读书笔记。后面7、8、9章分别讲的“测试、调试与重构”、“设计和架构的原则”以及“使用Lamb</description></item><item><title>「Java 8 函数式编程」读书笔记——高级集合类和收集器</title><link>/posts/java_8_lambdas_functional_programming_note_collector/</link><pubDate>Fri, 10 Feb 2017 00:00:00 +0000</pubDate><guid>/posts/java_8_lambdas_functional_programming_note_collector/</guid><description>本章是该书的第五章, 主要讲了方法引用和收集器 方法引用 形如: artist -&amp;gt; artist.getName() (String arg) -&amp;gt; arg.length() 这样的表达式, 可以简写为: Artist::getName String::length 这种简写的语法被称为方法引用. 方法引用</description></item><item><title>「Java 8 函数式编程」读书笔记——类库</title><link>/posts/java_8_lambdas_functional_programming_note_lib/</link><pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate><guid>/posts/java_8_lambdas_functional_programming_note_lib/</guid><description>本书第四章的读书笔记, 本章主要阐述: 如何使用Lambda表达式. 基本类型 考虑到装箱类型过于占用内存, JDK提供了针对基本类型的操作, 以达到优</description></item><item><title>「Java 8 函数式编程」读书笔记——流</title><link>/posts/java_8_lambdas_functional_programming_note_stream/</link><pubDate>Mon, 06 Feb 2017 00:00:00 +0000</pubDate><guid>/posts/java_8_lambdas_functional_programming_note_stream/</guid><description>本文是「Java 8 函数式编程」第三章的读书笔记，章名为流。本章主要介绍了外部迭代与内部迭代以及常用的高阶函数。 外部迭代与内部迭代 外部迭代 过去</description></item><item><title>「Java 8 函数式编程」读书笔记——lambda表达式</title><link>/posts/java_8_lambdas_functional_programming_note_lambda_expression/</link><pubDate>Sun, 05 Feb 2017 00:00:00 +0000</pubDate><guid>/posts/java_8_lambdas_functional_programming_note_lambda_expression/</guid><description>本文是「Java 8 函数式编程」第二章的读书笔记。 Lambda引入的变化 Lambda表达式，是一种紧凑的、传递行为的方式，从编程思想上来讲，就</description></item></channel></rss>