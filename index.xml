<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>无糖拿铁，谢谢</title><link>/</link><description>Recent content on 无糖拿铁，谢谢</description><generator>Hugo -- gohugo.io</generator><copyright>CC BY-NC 4.0 CN</copyright><lastBuildDate>Fri, 02 Oct 2020 21:38:48 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Jackson 处理抽象类的序列化和反序列化</title><link>/posts/jackson-inheritance/</link><pubDate>Fri, 02 Oct 2020 21:38:48 +0000</pubDate><guid>/posts/jackson-inheritance/</guid><description>Json 的序列化和反序列化是我们常见的操作，很多库都提供了这样的能力帮助我们完成这样的操作。 但业务有时可能变得稍微有些复杂，需要将一个抽象类的子类</description></item><item><title>圈复杂度</title><link>/posts/cyclomatic-complexity/</link><pubDate>Sat, 15 Aug 2020 16:56:16 +0000</pubDate><guid>/posts/cyclomatic-complexity/</guid><description>过去我知道有圈复杂度这个概念，它代表了代码的复杂程度。但是却没有了解过它是怎么算出来的，哪些代码会影响它的结果。 今天我们就来看一下，圈复杂度</description></item><item><title>Eureka 中的幽灵 —— Self Preservation 导致的幽灵服务</title><link>/posts/eureka-self-preservation-mode/</link><pubDate>Sat, 25 Jul 2020 23:31:52 +0000</pubDate><guid>/posts/eureka-self-preservation-mode/</guid><description>Eureka 是 Spring Cloud Netflix 的服务注册与发现工具。一般情况下，它都能很好的工作，但有时却会出现一些匪夷所思的情况。 今天我们就来研究一下不当的配置导致的幽灵服务</description></item><item><title>如何使用 Spring Security ACL</title><link>/posts/how-to-use-spring-security-acl/</link><pubDate>Sat, 18 Jul 2020 12:17:26 +0000</pubDate><guid>/posts/how-to-use-spring-security-acl/</guid><description>在上一篇文章中，我们了解了 Spring Security ACL 的基本概念。 但是几乎没有涉及实现与使用的部分。这篇文章我们就来看一看如何在使用了 Spring 的项目中使用 Spring Securi</description></item><item><title>Spring Security ACL 核心概念和组件</title><link>/posts/spring-security-acl-conception-and-component/</link><pubDate>Thu, 02 Jul 2020 01:21:40 +0000</pubDate><guid>/posts/spring-security-acl-conception-and-component/</guid><description>Spring Security 提供了一个 ACL 模块，也就是 Access Control List，用来做访问控制。 目的是解决 谁对什么资源有什么权限 的问题。 这里的重点是具体的资源。 面临的问题 我们通过</description></item><item><title>你的 docker stop，它优雅吗？</title><link>/posts/graceful-shutdown-docker-container/</link><pubDate>Thu, 18 Jun 2020 22:46:13 +0000</pubDate><guid>/posts/graceful-shutdown-docker-container/</guid><description>我们平时在使用 Docker 的时候，一般会使用 ctrl+c 或者 docker stop 的方式关闭容器。 但有时候我们可能会遇到 ctrl+c 不生效，或者 docker stop 之后要等待 10s 的情况，就像这样： 也许你会觉</description></item><item><title>Spring Security 的权限验证</title><link>/posts/spring-security-authorization/</link><pubDate>Sat, 13 Jun 2020 16:33:33 +0000</pubDate><guid>/posts/spring-security-authorization/</guid><description>在前面的文章里，我们对 Spring Security 进行权限验证的组件有了大致的了解，我们首先来回顾并探究一下细节。 Figure 1. 本文涉及到的组件 FilterSecurityInterceptor 这是 AbstractSecurityInterceptor 的一个子类，并且实现了</description></item><item><title>Spring Security 中的身份认证</title><link>/posts/spring-security-authentication/</link><pubDate>Sun, 07 Jun 2020 22:04:29 +0000</pubDate><guid>/posts/spring-security-authentication/</guid><description>本文介绍 Spring Security 的身份认证的内容，研究 Spring Security 自带的身份认证方式和添加自己的身份认证方式的方法。 身份认证相关组件 在上一篇文章中，我们了解到了 Spring Security 会将</description></item><item><title>Spring Security Servlet 概览</title><link>/posts/spring-security-servlet-overview/</link><pubDate>Sun, 31 May 2020 19:58:38 +0000</pubDate><guid>/posts/spring-security-servlet-overview/</guid><description>Spring Security 是 Spring 框架中用于实现 Security 相关需求的项目。我们可以通过使用这个框架来实现项目中的安全需求。 今天这篇文章将会讨论 Spring Security Servlet 是如何工作的。 之所以将内容</description></item><item><title>使用 Gradle 的 Java 插件构建 Java 项目</title><link>/posts/use-gradle-to-build-java-project/</link><pubDate>Mon, 24 Feb 2020 21:09:31 +0000</pubDate><guid>/posts/use-gradle-to-build-java-project/</guid><description>在上一篇文章中，我们在没有使用任何插件的情况下，练习了使用 Gradle 构建 Java 项目，最后得到一个脆弱的构建脚本和不符合约定的目录结构。 对此，Gradle</description></item><item><title>使用 Gradle 但不使用 Java 插件构建 Java 项目</title><link>/posts/use-gradle-to-build-java-project-without-plugin/</link><pubDate>Sat, 22 Feb 2020 23:42:35 +0000</pubDate><guid>/posts/use-gradle-to-build-java-project-without-plugin/</guid><description>本文目标是探索在没有使用任何额外插件的情况下，如何使用 Gradle 构建一个 Java 项目，以此对比使用 Java 插件时得到的好处。 初始化项目 使用 Gradle Init 插件提供的 init task 来创</description></item><item><title>《微服务架构设计模式》读书总结</title><link>/posts/microservice-arch-pattern/</link><pubDate>Sat, 01 Feb 2020 02:53:38 +0000</pubDate><guid>/posts/microservice-arch-pattern/</guid><description>《微服务架构设计模式》这本书介绍了引入微服务架构后面临的挑战，提供了一些模式用于应对这些挑战。所有的模式都可以在 作者的网站上找到，书上只是使</description></item><item><title>端口与适配器架构</title><link>/posts/hexagonal-architecture/</link><pubDate>Sun, 05 Jan 2020 19:26:44 +0000</pubDate><guid>/posts/hexagonal-architecture/</guid><description>端口与适配器架构又被称为六边形架构，是一种约定代码设计的架构。它解决的是如何设计代码的问题，主要的关注点在于业务与技术的解耦。 第一次看到这个</description></item><item><title>Spring 里那么多种 CORS 的配置方式，到底有什么区别</title><link>/posts/how-spring-implement-cors/</link><pubDate>Fri, 14 Jun 2019 22:14:37 +0000</pubDate><guid>/posts/how-spring-implement-cors/</guid><description>作为一个后端开发，我们经常遇到的一个问题就是需要配置 CORS，好让我们的前端能够访问到我们的 API，并且不让其他人访问。而在 Spring 中，我们见过很</description></item><item><title>HTTP Headers 之 Origin</title><link>/posts/http-headers-origin/</link><pubDate>Thu, 23 May 2019 21:33:34 +0000</pubDate><guid>/posts/http-headers-origin/</guid><description>概念 HTTP 协议中的 Origin Header 存在于请求中，用于指明当前请求来自于哪个站点。 字段内容 Origin 仅仅包含站点信息，不包含任何路径信息。 语法 Origin: &amp;#34;&amp;#34; Origin: &amp;#34;&amp;lt;schema&amp;gt;://&amp;lt;host&amp;gt;[:port]&amp;#34; // 例如 Origin: &amp;#34;https://baidu.com&amp;#34; // 错误</description></item><item><title>Java内存回收算法介绍</title><link>/posts/java-memory-collection-algorithms/</link><pubDate>Sun, 10 Feb 2019 22:18:24 +0000</pubDate><guid>/posts/java-memory-collection-algorithms/</guid><description>JVM 提供了自动化的内存管理，使得开发者不需要编写内存回收的代码。但是，JVM 是如何工作的呢？是如何知道哪些内存应该被清理呢？又如何减小垃圾回收</description></item><item><title>使用 git submodule 管理 Hexo 博客的主题</title><link>/posts/use-git-submodule-to-manage-your-hexo-theme/</link><pubDate>Thu, 20 Dec 2018 01:26:17 +0000</pubDate><guid>/posts/use-git-submodule-to-manage-your-hexo-theme/</guid><description>个人十分喜欢 Hexo 博客框架下的 NexT 主题，所以自己的博客也就选择的这个主题。然而最近换了电脑之后傻眼了，git clone 之后发现 themes/next 是个空目录，github 上</description></item><item><title>什么是 Twelve-Factor App</title><link>/posts/what-is-12-factors-app/</link><pubDate>Thu, 27 Sep 2018 01:14:37 +0000</pubDate><guid>/posts/what-is-12-factors-app/</guid><description>在学习 Spring Cloud 的时候，文档一开始就提到了一个概念：Twelve-Factor App。这勾起了我的好奇心，刚好有个网站用来解释这个东西，这里谈谈我</description></item><item><title>创建自己的 Spring auto-configuration</title><link>/posts/create-your-own-spring-auto-configuration/</link><pubDate>Tue, 21 Aug 2018 11:19:05 +0000</pubDate><guid>/posts/create-your-own-spring-auto-configuration/</guid><description>Spring Boot 为我们带来了自动配置的舒适体验，极大的提高了开发效率。当我们需要使用第三方库，而这些库没有实现 Spring Boot Auto-Configururation 时，我们为了避免在不同项目中的重复配</description></item><item><title>码农一年小结</title><link>/posts/biref-summary-of-one-year-of-work/</link><pubDate>Thu, 02 Aug 2018 23:29:30 +0000</pubDate><guid>/posts/biref-summary-of-one-year-of-work/</guid><description>还差几天就工作满一年了，记录一下一些不足以写成博客的经验吧。 关于数据库访问层 做后端开发必定是要访问数据库的，经历的几个项目分别使用了 JDBCTemplate 和 QueryDSL ，</description></item><item><title>契约测试小结</title><link>/posts/contracts-test-brief-summary/</link><pubDate>Fri, 20 Jul 2018 00:40:10 +0000</pubDate><guid>/posts/contracts-test-brief-summary/</guid><description>现在的项目上在尝试契约测试这个东西，使用了大半年，再加上业余的一些研究，简单的总结一下。 契约测试解决的问题 契约测试是在微服务实践中提出的，目</description></item><item><title>Http Header 中的 referer 字段</title><link>/posts/http-hearders-referer/</link><pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate><guid>/posts/http-hearders-referer/</guid><description>在做企业微信应用开发的时候，有使用第三方单点登录的需求。根据企业微信的文档，设置好登录授权发起域名和回调域名后，编写了一个Controlle</description></item><item><title>定制Java中的Validation</title><link>/posts/custome_validation_in_java/</link><pubDate>Wed, 25 Oct 2017 00:00:00 +0000</pubDate><guid>/posts/custome_validation_in_java/</guid><description>Java Validation简介 javax.validation包提供了大量用于验证数据的API工具，可以帮助开发者方便的检验程序的输入输出。最近</description></item><item><title>SpringMVC中Controller的测试</title><link>/posts/springmvc%E4%B8%ADcontroller%E7%9A%84%E6%B5%8B%E8%AF%95/</link><pubDate>Sun, 04 Jun 2017 00:00:00 +0000</pubDate><guid>/posts/springmvc%E4%B8%ADcontroller%E7%9A%84%E6%B5%8B%E8%AF%95/</guid><description>参考 http://www.jianshu.com/p/ad7995332dd9 controller: @Controller @RequestMapping(&amp;#34;/system&amp;#34;) public class SysMapController { @Autowired private FirstSysMapService firstSysMapService;//注入Service @RequestMapping(value = &amp;#34;/first/map&amp;#34;, method = RequestMethod.GET, produces = {&amp;#34;application/json;charset=UTF-8&amp;#34;}) @ResponseBody//响应类</description></item><item><title>「JavaScript 语言精粹」读书笔记--函数</title><link>/posts/javascript_the_good_parts_function/</link><pubDate>Mon, 06 Mar 2017 00:00:00 +0000</pubDate><guid>/posts/javascript_the_good_parts_function/</guid><description>函数对象 JavaScript中函数就是对象. 函数对象连接到Function.prototype. 当把一个函数当作构造函数(使用new关键字)</description></item><item><title>「JavaScript 语言精粹」读书笔记--对象</title><link>/posts/javascritp_the_good_parts_object/</link><pubDate>Sat, 04 Mar 2017 00:00:00 +0000</pubDate><guid>/posts/javascritp_the_good_parts_object/</guid><description>前两章介绍基础, 没什么笔记好记录. 这是第三章. 什么是对象 在JavaScript中, 除了简单数据类型(数字, 字符串, 布尔值, null和unde</description></item><item><title>「Java 8 函数式编程」读书笔记——数据并行化</title><link>/posts/java_8_lambdas_functional_programming_note_parallel/</link><pubDate>Mon, 20 Feb 2017 00:00:00 +0000</pubDate><guid>/posts/java_8_lambdas_functional_programming_note_parallel/</guid><description>本书第六章的读书笔记，也是我这个系列的最后一篇读书笔记。后面7、8、9章分别讲的“测试、调试与重构”、“设计和架构的原则”以及“使用Lamb</description></item><item><title>「Java 8 函数式编程」读书笔记——高级集合类和收集器</title><link>/posts/java_8_lambdas_functional_programming_note_collector/</link><pubDate>Fri, 10 Feb 2017 00:00:00 +0000</pubDate><guid>/posts/java_8_lambdas_functional_programming_note_collector/</guid><description>本章是该书的第五章, 主要讲了方法引用和收集器 方法引用 形如: artist -&amp;gt; artist.getName() (String arg) -&amp;gt; arg.length() 这样的表达式, 可以简写为: Artist::getName String::length 这种简写的语法被称为方法引用. 方法引用</description></item><item><title>「Java 8 函数式编程」读书笔记——类库</title><link>/posts/java_8_lambdas_functional_programming_note_lib/</link><pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate><guid>/posts/java_8_lambdas_functional_programming_note_lib/</guid><description>本书第四章的读书笔记, 本章主要阐述: 如何使用Lambda表达式. 基本类型 考虑到装箱类型过于占用内存, JDK提供了针对基本类型的操作, 以达到优</description></item><item><title>「Java 8 函数式编程」读书笔记——流</title><link>/posts/java_8_lambdas_functional_programming_note_stream/</link><pubDate>Mon, 06 Feb 2017 00:00:00 +0000</pubDate><guid>/posts/java_8_lambdas_functional_programming_note_stream/</guid><description>本文是「Java 8 函数式编程」第三章的读书笔记，章名为流。本章主要介绍了外部迭代与内部迭代以及常用的高阶函数。 外部迭代与内部迭代 外部迭代 过去</description></item><item><title>「Java 8 函数式编程」读书笔记——lambda表达式</title><link>/posts/java_8_lambdas_functional_programming_note_lambda_expression/</link><pubDate>Sun, 05 Feb 2017 00:00:00 +0000</pubDate><guid>/posts/java_8_lambdas_functional_programming_note_lambda_expression/</guid><description>本文是「Java 8 函数式编程」第二章的读书笔记。 Lambda引入的变化 Lambda表达式，是一种紧凑的、传递行为的方式，从编程思想上来讲，就</description></item><item><title>使用AOP获取RequestBody</title><link>/posts/get_requestbody_by_aop/</link><pubDate>Sun, 20 Nov 2016 00:00:00 +0000</pubDate><guid>/posts/get_requestbody_by_aop/</guid><description>一开始使用spring拦截器拦截请求记录日志,对于请求路径、header这些都很好获取,唯独POST请求无法获取其中的RequestBody</description></item><item><title>服务器配置小记</title><link>/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AE%B0/</link><pubDate>Thu, 17 Nov 2016 00:00:00 +0000</pubDate><guid>/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AE%B0/</guid><description>最近一个项目要上线了,需要搭服务器,本来是交给同学搭的,结果遇到了大坑,还得自己来,今天把这些坑记一下. 服务器有好几台,都是CentOS6.</description></item><item><title>Spring高级装配之运行时注入</title><link>/posts/spring%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B3%A8%E5%85%A5/</link><pubDate>Wed, 17 Aug 2016 00:00:00 +0000</pubDate><guid>/posts/spring%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B3%A8%E5%85%A5/</guid><description>{:toc #zhuru} 运行时注入与硬编码注入是相对的。硬编码注入在编译时就已经确定了，运行时注入则可能需要一些外部的参数来解决。 Spring提供的两种在运行时</description></item><item><title>Sort Colors 解题思路</title><link>/posts/sort-solors-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</link><pubDate>Fri, 29 Jul 2016 00:00:00 +0000</pubDate><guid>/posts/sort-solors-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</guid><description>题目 先把题目放上： 链接：https://leetcode.com/problems/sort-colors Given an array with n objects colored red, white or blue, sort them so that objects of</description></item><item><title>利用NGINX反向代理避免跨域</title><link>/posts/%E5%88%A9%E7%94%A8nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%81%BF%E5%85%8D%E8%B7%A8%E5%9F%9F/</link><pubDate>Tue, 07 Jun 2016 00:00:00 +0000</pubDate><guid>/posts/%E5%88%A9%E7%94%A8nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%81%BF%E5%85%8D%E8%B7%A8%E5%9F%9F/</guid><description>在慕课网上看了高并发的课程，准备用spring+Mybaits来开发新的项目。遇到了前端跨域请求的问题。 服务器上nginx+tomcat，其</description></item><item><title>从http到https</title><link>/posts/from_http_to_https/</link><pubDate>Fri, 27 May 2016 00:00:00 +0000</pubDate><guid>/posts/from_http_to_https/</guid><description>这个五一折腾了下https，看了加密的建立过程和原理，然后动手实践，把博客从不支持https的阿里云虚机上搬到了新买的腾讯云的主机上，配好了</description></item></channel></rss>