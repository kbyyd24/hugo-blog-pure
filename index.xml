<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>无糖拿铁，谢谢</title><link>https://blog.gaoyuexiang.cn/</link><description>学习、记录、分享</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>blog@gaoyuexiang.cn (无糖拿铁)</managingEditor><webMaster>blog@gaoyuexiang.cn (无糖拿铁)</webMaster><copyright>CC BY-NC 4.0 CN</copyright><lastBuildDate>Mon, 10 Jun 2024 21:00:50 +0800</lastBuildDate><atom:link href="https://blog.gaoyuexiang.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Openwrt 磁盘扩容踩坑记</title><link>https://blog.gaoyuexiang.cn/extend-openwrt-disk-size/</link><pubDate>Mon, 10 Jun 2024 21:00:50 +0800</pubDate><author>作者</author><guid>https://blog.gaoyuexiang.cn/extend-openwrt-disk-size/</guid><description>前几天我准备给 openwrt 里的一个软件升级一下，下载的过程中却遇到磁盘空间不足的问题，于是搜索了一下别人写的文章，照着步骤进行扩容，却始终不成功。这里</description></item><item><title>函数式编程给代码设计带来了什么变化？</title><link>https://blog.gaoyuexiang.cn/what-we-can-learn-from-functional-programming-for-projects/</link><pubDate>Tue, 14 May 2024 16:38:19 +0800</pubDate><author>作者</author><guid>https://blog.gaoyuexiang.cn/what-we-can-learn-from-functional-programming-for-projects/</guid><description>我第一次接触函数式编程还是在大学的时候，学长实习回来给我介绍了这个新的概念。后来通过阅读《Java8 函数式编程》，我入门了函数式的一些常见方</description></item><item><title>零成本实现软路由</title><link>https://blog.gaoyuexiang.cn/rebuild-family-network-with-low-cost/</link><pubDate>Tue, 27 Dec 2022 21:31:54 +0800</pubDate><author>作者</author><guid>https://blog.gaoyuexiang.cn/rebuild-family-network-with-low-cost/</guid><description>之前在了解到软路由之后，一直想给自己的网络也搞一个软路由。这样就不需要在每个设备上进行配置，也可以让一些没有软件支持的设备（比如 xbox）也</description></item><item><title>重装了 Windows，这些东西又得装一遍</title><link>https://blog.gaoyuexiang.cn/windows-setup/</link><pubDate>Tue, 01 Feb 2022 15:58:19 +0800</pubDate><author>作者</author><guid>https://blog.gaoyuexiang.cn/windows-setup/</guid><description>surface 升级到 Windows 11 之后，开始出现莫名其妙的屏闪。在更新驱动也不能改善之后，我还是选择了重装系统。虽然保留了个人数据，但是所有的应用都没有了，不得不</description></item><item><title>JUnit 不好用？也许你可以试试这些测试工具</title><link>https://blog.gaoyuexiang.cn/junit_alternative/</link><pubDate>Fri, 26 Nov 2021 00:01:57 +0800</pubDate><author>作者</author><guid>https://blog.gaoyuexiang.cn/junit_alternative/</guid><description>在我们日常的 TDD 开发中，永远绕不过去的就是要编写测试。而对于一个 Java 程序员，JUnit 似乎是一个不二的选择。它的确是一个十分优秀的工具，在大多数</description></item><item><title>以领域为核心的架构们如何指导我们写代码</title><link>https://blog.gaoyuexiang.cn/domain-centeric-architectures/</link><pubDate>Tue, 25 May 2021 22:13:57 +0800</pubDate><author>作者</author><guid>https://blog.gaoyuexiang.cn/domain-centeric-architectures/</guid><description>刚开始工作的时候就接触到 DDD，当时就被它规定的代码模式所吸引。几年下来，接触到不同的代码组织模式，更是深深的感受到一个“良好”的代码架构是</description></item><item><title>发散式变化与霰弹式修改</title><link>https://blog.gaoyuexiang.cn/divergent-change-and-shotgun-surgery/</link><pubDate>Sun, 25 Apr 2021 20:22:33 +0800</pubDate><author>作者</author><guid>https://blog.gaoyuexiang.cn/divergent-change-and-shotgun-surgery/</guid><description>发散式变化和霰弹式修改是 Martin Fowler 在《重构》中收录的两种代码坏味道。看到这两个名字时，我并不理解它们描述的是什么样的代码。也许我已经遇到过这样的代</description></item><item><title>要扫描 Java 的 package 中有某个注解的类，应该怎么做？</title><link>https://blog.gaoyuexiang.cn/how-to-scan-classes-in-java-package-with-annotation/</link><pubDate>Sun, 21 Mar 2021 19:52:45 +0800</pubDate><author>作者</author><guid>https://blog.gaoyuexiang.cn/how-to-scan-classes-in-java-package-with-annotation/</guid><description>在 Java 自带的反射库中，我们只能根据具体的一个完整类名去加载一个类。如果我们想要在一个 package 中扫描所有的符合条件的类，就需要自己写代码实现。 但是作为</description></item><item><title>使用 Jackson 处理抽象类的序列化和反序列化</title><link>https://blog.gaoyuexiang.cn/jackson-inheritance/</link><pubDate>Fri, 02 Oct 2020 21:38:48 +0000</pubDate><author>作者</author><guid>https://blog.gaoyuexiang.cn/jackson-inheritance/</guid><description>Json 的序列化和反序列化是我们常见的操作，很多库都提供了这样的能力帮助我们完成这样的操作。 但业务有时可能变得稍微有些复杂，需要将一个抽象类的子类</description></item><item><title>圈复杂度</title><link>https://blog.gaoyuexiang.cn/cyclomatic-complexity/</link><pubDate>Sat, 15 Aug 2020 16:56:16 +0000</pubDate><author>作者</author><guid>https://blog.gaoyuexiang.cn/cyclomatic-complexity/</guid><description>过去我知道有圈复杂度这个概念，它代表了代码的复杂程度。但是却没有了解过它是怎么算出来的，哪些代码会影响它的结果。 今天我们就来看一下，圈复杂度</description></item></channel></rss>